/*
	Copyright (c) 2013, Keripo
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	    * Neither the name of the <organization> nor the
	      names of its contributors may be used to endorse or promote products
	      derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

using System;
using System.IO;
using System.Collections.Generic;

namespace Beats2.Data {

	/// <summary>
	/// Parser for .sm/.ssc files (StepMania)
	/// References:
	/// .sm: http://www.stepmania.com/wiki/The_.SM_file_format
	/// .ssc: http://www.stepmania.com/wiki/The_.SSC_file_format
	///
	/// Did I ever mention how I hate the lack of format strictness in .sm files?
	/// Well, I hate the lack of format strictness in .sm files
	/// Comments being allowed to be placed anywhere, semi-colon line endings
	/// sometimes on the same line, sometimes not, sometimes even missing, etc.
	/// This will probably work for 90% of .sm files and break on that 10% that's hand-edited
	/// or generated by DancingMonkeys/etc.
	/// Minimal error checking because fk you.
	/// If you can write a better parser, go ahead and submit a patch.
	/// ~Keripo
	/// </summary>
	public class ParserSM : ParserBase {
		new protected const string TAG = "ParserSM";

		/// <summary>
		/// Minimum .ssc format version supported by this parser
		/// </summary>
		private const int MIN_VERSION = 1;

		/// <summary>
		/// In .sm format, each measure totals to 4 beats
		/// </summary>
		private const int BEATS_PER_MEASURE = 4;

		/// <summary>
		/// BPM change indexed by a beat (instead of a time)
		/// </summary>
		protected class Bpm : IComparable<Bpm> {

			/// <summary>
			/// The beat at which the BPM change starts
			/// </summary>
			public float beat;

			/// <summary>
			/// The new BPM value to change to
			/// </summary>
			public float bpm;

			/// <summary>
			/// Comparator for sorting, compares <see cref="Bpm.beat"/> values
			/// </summary>
			public int CompareTo(Bpm other) {
				return beat.CompareTo(other.beat);
			}
		}
		/// <summary>
		/// List of beat-indexed <see cref="BPM"/>
		/// </summary>
		private List<Bpm> _bpms = new List<Bpm>();

		/// <summary>
		/// Stop duration indexed by a beat (instead of a time)
		/// </summary>
		protected class Stop : IComparable<Stop> {

			/// <summary>
			/// The beat at which the Stop event starts
			/// </summary>
			public float beat;

			/// <summary>
			/// The duration of the Stop event
			/// </summary>
			public float duration;

			/// <summary>
			/// Comparator for sorting, compares <see cref="Stop.beat"/> values
			/// </summary>
			public int CompareTo(Stop other) {
				return beat.CompareTo(other.beat);
			}
		}
		/// <summary>
		/// List of beat-indexed <see cref="Stop"/>
		/// </summary>
		private List<Stop> _stops = new List<Stop>();

		/// <summary>
		/// Background change indexed by a beat (instead of a time)
		/// </summary>
		protected class Bg : IComparable<Bg> {

			/// <summary>
			/// The beat at which the background change event starts
			/// </summary>
			public float beat;

			/// <summary>
			/// The filename of the background image file
			/// </summary>
			public string filename;

			/// <summary>
			/// Comparator for sorting, compares <see cref="Bg.beat"/> values
			/// </summary>
			public int CompareTo(Bg other) {
				return beat.CompareTo(other.beat);
			}
		}
		/// <summary>
		/// List of beat-indexed <see cref="Bg"/>
		/// </summary>
		private List<Bg> _bgs = new List<Bg>();

		/// <summary>
		/// Text label indexed by a beat (instead of a time)
		/// </summary>
		protected class Label : IComparable<Label> {

			/// <summary>
			/// The beat at which the text label event starts
			/// </summary>
			public float beat;

			/// <summary>
			/// The text to be shown
			/// </summary>
			public string text;

			/// <summary>
			/// Comparator for sorting, compares <see cref="Label.beat"/> values
			/// </summary>
			public int CompareTo(Label other) {
				return beat.CompareTo(other.beat);
			}
		}
		/// <summary>
		/// List of beat-indexed <see cref="Label"/>
		/// </summary>
		private List<Label> _labels = new List<Label>();

		/// <summary>
		/// Queue for hold notes, array size should be the same as <see cref="Pattern.keyCount"/>
		/// </summary>
		public Note[] _holdQueue;

		/// <summary>
		/// Checks the .ssc format version
		/// </summary>
		private void CheckVersion(string val) {
			int version = this.ParseInt("Version", val, true);
			if (version < MIN_VERSION) {
				Error("Format version of " + version + " is less than the minimum supported version " + MIN_VERSION);
			}
		}

		/// <summary>
		/// Parses a key-value pair using ':' as the separator, see <see cref="ParserBase.ParseKeyValuePair"/>
		/// </summary>
		private bool ParseKeyValuePair(string line, out string key, out string val) {
			return this.ParseKeyValuePair(line, ':', out key, out val);
		}

		/// <summary>
		/// Parses the song offset as a Stop
		/// </summary>
		public void ParseOffset(string val) {
			float offset = 0f;
			if (!float.TryParse(val, out offset)) {
				Error("Unable to parse offset value: " + val);
			}

			// Hack to make time calculations easier
			Stop stop = new Stop();
			stop.beat = -1f;
			stop.duration = offset;
			_stops.Add(stop);
		}

		/// <summary>
		/// Calculates the timestamp of a beat, uses <see cref="_bpms"/> and <see cref="_stops"/>
		/// </summary>
		private float CalculateTime(float beat) {
			float time = 0f;

			// Add time increase from Bpm changes
			Bpm lastBpm = _bpms[0];
			for (int i = 0; i < _bpms.Count; i++) {
				Bpm bpm = _bpms[i];
				if (bpm.beat <= beat) {
					time += lastBpm.bpm * (bpm.beat - lastBpm.beat);
					lastBpm = bpm;
				} else {
					// Add last bit of time
					time += lastBpm.bpm * (beat - lastBpm.beat);
				}
			}

			// Add time increase from Stops
			for (int i = 0; i < _stops.Count; i++) {
				Stop stop = _stops[i];
				if (stop.beat < beat) {
					time += stop.duration;
				}
			}

			return time;
		}

		/// <summary>
		/// Parses for DisplayBPM values
		/// </summary>
		private List<float> ParseDisplayBpms(string val) {
			List<float> bpms = new List<float>();
			foreach (string s in val.Split(':')) {
				if (s == "*") {
					bpms.Add(Info.RANDOM_DISPLAY_BPM);
				} else {
					float bpm = this.ParseFloat("DisplayBpm", s, false);
					if (bpm > 0f) { // Screw StepMania negative BPMs!
						bpms.Add(bpm);
					}
				}
			}
			return bpms;
		}

		/// <summary>
		/// Parses for the default background image
		/// </summary>
		private void ParseBackground(string val) {
			string background = this.FindImageFile("Background", val, false);
			if (background != null) {
				Bg bg = new Bg();
				bg.beat = 0f;
				bg.filename = background;
				_bgs.Add(bg);
			}
		}

		/// <summary>
		/// Parses for subsequent background images, currently no support for videos
		/// </summary>
		private void ParseBackgrounds(string val) {
			string[] commaSplit = val.Split(',');
			foreach (string split in commaSplit) {
				string[] equalsSplit = split.Split('=');
				if (equalsSplit.Length < 2) {
					Warning("Improperly formatted #BGCHANGES value: " + split);
					continue;
				}
				float beat = this.ParseFloat("Background change beat", equalsSplit[0], false);
				string background = this.FindImageFile("Background change background", equalsSplit[1], false);
				if (beat != -1f && background != null) {
					Bg bg = new Bg();
					bg.beat = beat;
					bg.filename = background;
					_bgs.Add(bg);
				}
			}
		}

		/// <summary>
		/// Parses the BPM change events
		/// </summary>
		private void ParseBpms(string val) {
			string[] commaSplit = val.Split(',');
			foreach (string split in commaSplit) {
				string[] equalsSplit = split.Split('=');
				if (equalsSplit.Length < 2) {
					Warning("Improperly formatted #BPMS value: " + split);
					continue;
				}
				float beat = this.ParseFloat("BPM change beat", equalsSplit[0], false);
				float bpmVal = this.ParseFloat("BPM change bpm", equalsSplit[1], false);
				if (beat != -1f && bpmVal != -1f) {
					Bpm bpm = new Bpm();
					bpm.beat = beat;
					bpm.bpm = bpmVal;
					_bpms.Add(bpm);
				}
			}
		}
		
		/// <summary>
		/// Parses the Stop/Delay events. Note that Beats2 treats Delays as Stops (for unification reasons)
		/// </summary>
		private void ParseStops(string val) {
			string[] commaSplit = val.Split(',');
			foreach (string split in commaSplit) {
				string[] equalsSplit = split.Split('=');
				if (equalsSplit.Length < 2) {
					Warning("Improperly formatted #STOPS value: " + split);
					continue;
				}
				float beat = this.ParseFloat("STOP beat", equalsSplit[0], false);
				float duration = this.ParseFloat("STOP bpm", equalsSplit[1], false);
				if (beat != -1f && duration != -1f) {
					Stop stop = new Stop();
					stop.beat = beat;
					stop.duration = duration;
					_stops.Add(stop);
				}
			}
		}

		/// <summary>
		/// Parses the Label events
		/// </summary>
		private void ParseLabels(string val) {
			string[] commaSplit = val.Split(',');
			foreach (string split in commaSplit) {
				string[] equalsSplit = split.Split('=');
				if (equalsSplit.Length < 2) {
					Warning("Improperly formatted #LABELS value: " + split);
					continue;
				}
				float beat = this.ParseFloat("LABEL beat", equalsSplit[0], false);
				string text = equalsSplit[1];
				if (beat != -1f) {
					Label label = new Label();
					label.beat = beat;
					label.text = text;
					_labels.Add(label);
				}
			}
		}

		/// <summary>
		/// Parses the key count, based on the given .sm "NoteType"
		/// </summary>
		private int ParseKeyCount(string val) {
			switch(val) {
				case "dance-single":	return 4;
				case "dance-double":	return 8;
				case "dance-couple":	return 8;
				case "dance-solo":		return 6;
				case "pump-single":		return 5;
				case "pump-double":		return 10;
				case "pump-couple":		return 10;
				case "ez2-single":		return 5;
				case "ez2-double":		return 10;
				case "ez2-real":		return 7;
				case "para-single":		return 5;
				default:				return -1;
			}
		}

		/// <summary>
		/// Parses a pattern section
		/// </summary>
		private Pattern ParsePattern(string buffer) {
			// We'll assume there's 5 colons before the notes data. If not, this breaks
			string[] colonSplit = _line.Split(':');
			if (colonSplit.Length != 5) {
				this.Error("Incorrectly formatted #NOTES metadata");
			}

			// Parse key count
			int keyCount;
			if ((keyCount = this.ParseKeyCount(colonSplit[0])) == -1) {
				this.Error("Unable to parse sectionkey count");
			}
			_holdQueue = new Note[keyCount];

			// Parse description
			string description = colonSplit[1];

			// Parse difficulty level
			int difficulty;
			if (!int.TryParse(colonSplit[3], out difficulty)) {
				this.Error("Unable to parse difficulty level of #NOTES metadata");
			}

			// Note: We don't care about DifficultyClass (Beats2 standardizes this based on difficulty level)
			// nor RadarValues (this seems to be a DDR-only thing)

			// Set the pattern
			Pattern pattern = new Pattern();
			pattern.type = PatternType.BEATS;
			pattern.keyCount = keyCount;
			pattern.difficulty = difficulty;
			pattern.description = description;
			pattern.lineIndex = _index + 1;
			pattern.loaded = false;

			return pattern;
		}

		public override void Load(string path) {
			base.Load(path);

			// Parse line-by-line
			_index = 0;
			_line = "";
			ReadAheadStreamReader reader = new ReadAheadStreamReader(path);

			// Main loop
			while ((reader.PeekLine()) != null) {
				_index++;
				_line = reader.ReadLine().Trim();

				// Empty line
				if (_line.Length == 0) {
					continue;
				// Comment
				} else if (_line[0] == '/') {
					continue;
				// Tag data
				} else if (_line[0] == '#') {
					// Parse key-value pair
					string key, val;
					if (!this.ParseKeyValuePair(_line, out key, out val)) {
						// Skip if not a key-value pair
						this.Warning("Unparsed line");
						continue;
					}

					// Pattern data
					if (key == "#NOTES") {
						// Read all the notes metadata into one buffer.
						// We'll assume there's 5 colons before the notes data. If not, this breaks
						_line = "";
						int colonCount = 0;
						while (colonCount < 5 && reader.PeekLine() != null) {
							_index++;
							_line += reader.ReadLine().Trim();
						}
						Pattern pattern = this.ParsePattern(_line);
						_info.patterns.Add(pattern);
					// Simfile info
					} else {

						// The .sm format specifies that keys be marked as ended with ';'
						// Usually this is on the same line, but not always
						if (val.IndexOf(';') != -1) {
							// Remove ending ';'
							val = val.Substring(0, val.IndexOf(';'));
						} else {
							string nextLine;
							while ((nextLine = reader.PeekLine()) != null) {
								// Key did not properly end with a ';'
								if (nextLine[0] == '#') {
									Warning("Improperly formatted .sm file");
									break;
								}
								// Valid next line, continue reading
								nextLine = reader.ReadLine();
								_index++;
								_line += nextLine;

								// Ignore empty lines or comments
								nextLine = nextLine.Trim();
								if (nextLine.Length == 0 || nextLine[0] == '/') {
									continue;
								}
								// Key ending line
								if (nextLine.IndexOf(';') == -1) {
									val += nextLine;
								// Key not ended yet
								} else {
									// Remove ending ';' and stop peeking
									val += nextLine.Substring(0, nextLine.IndexOf(';'));
									break;
								}
							}
						}

						// Set data based on key
						switch(key) {
							case "#VERSION":			this.CheckVersion(val);												break;
							case "#TITLE":				_info.title = val; 													break;
							case "#TITLETRANSLIT":		_info.titleTranslit = val;											break;
							case "#SUBTITLE":			_info.subtitle = val; 												break;
							case "#SUBTITLETRANSLIT":	_info.subtitleTranslit = val;										break;
							case "#ARTIST":				_info.artist = val;													break;
							case "#ARTISTTRANSLIT":		_info.artistTranslit = val;											break;
							case "#GENRE":				_info.genre = val;													break;
							case "#CREDIT":				_info.credits = val;												break;
							case "#BANNER":				_info.banner = this.FindImageFile("Banner", val, false);			break;
							case "#BACKGROUND":			this.ParseBackground(val);											break;
							case "#LYRICSPATH":			_info.lyrics = this.FindLyricsFile("Lyrics", val, false);			break;
							case "#CDTITLE":			_info.cover = this.FindImageFile("Cover", val, false);				break;
							case "#MUSIC":				_info.song = this.FindAudioFile("Song", val, true);					break;
							case "#OFFSET":				this.ParseOffset(val);												break;
							case "#SAMPLESTART":		_info.sampleStart = this.ParseFloat("SampleStart", val, false);		break;
							case "#SAMPLELENGTH":		_info.sampleLength = this.ParseFloat("SampleLength", val, false);	break;
							case "#DISPLAYBPM":			_info.displayBpm = this.ParseDisplayBpms(val);						break;
							case "#BPMS":				this.ParseBpms(val);												break;
							case "#BGCHANGE":			this.ParseBackgrounds(val);											break;
							case "#STOPS":				this.ParseStops(val);												break;
							case "#DELAYS":				this.ParseStops(val);												break;
							case "#LABELS":				this.ParseLabels(val);												break;
							// Ignored/unsupported
							// Mostly .ssc stuff that I don't understand or don't want to implement
							/*
								#SELECTABLE
								#LISTSORT
								#WARPS
								#TIMESIGNATURES
								#TICKCOUNT
								#COMBOS
								#SPEEDS
								#SCROLLS
								#FAKES
								#KEYSOUNDS
								#ATTACKS
							 */
							default:					this.Warning("Unsupported key: " + key);							break;
						}
					}
				} else {
					this.Warning("Unparsed line");
				}
			}

			// Sort things
			this.SortList<Bpm>(_bpms);
			this.SortList<Stop>(_stops);
			this.SortList<Bg>(_bgs);

			// Cleanup
			reader.Close();
		}

		/// <summary>
		/// Parses the NoteType
		/// Note that the return value is handled differently from <see cref="ParserBSF"/>,
		/// specifically a <see cref="NoteType.SLIDE"/> (unused in the Beats style) will be returned
		/// in place of Hold/Roll end notes since in Beats2, notes are treated as one complete object
		/// </summary>
		private NoteType ParseNoteType(char c) {
			switch (c) {
				case '0': return NoteType.UNKNOWN;
				case '1': return NoteType.TAP;
				case '2': return NoteType.HOLD;
				case '3': return NoteType.SLIDE; // Hold/Roll end
				case '4': return NoteType.ROLL;
				case 'M': return NoteType.MINE;
				case 'L': return NoteType.HOLD; // Lift
				case 'F': return NoteType.UNKNOWN; // Fake
				default: return NoteType.UNKNOWN;
			}
		}

		/// <summary>
		/// Parses notes data
		/// </summary>
		private void ParseMeasure(Pattern pattern, float beatStart, List<string> measure) {
			// Amount of beat increase per line
			// Note that in StepMania, the beat fraction is important note data for
			// determining the note colour.
			// In Beats2, to standardize things, we ignore beat fraction
			// (it also gives an unequal timing compared to other modes)
			float beatFraction = (float)BEATS_PER_MEASURE / (float)measure.Count;

			NoteType type;
			Note note;
			float beat = 0f;
			float time;
			string line;

			// Down each line
			for (int i = 0; i < measure.Count; i++) {
				line = measure[i];
				beat += beatFraction;
				time = this.CalculateTime(beat);
				// Across each line, width should match the key count
				for (int column = 0; column < pattern.keyCount; column++) {
					type = this.ParseNoteType(line[column]);
					switch(type) {
						case NoteType.MINE:
						case NoteType.TAP:
							note = new Note();
							note.type = type;
							note.AddPoint(time, column);
							this.AddNote(pattern, note);
							break;
						case NoteType.HOLD:
						case NoteType.ROLL:
							note = new Note();
							note.type = type;
							note.AddPoint(time, column);

							// Queue the note and wait for end
							if (_holdQueue[column] != null) {
								this.Warning("Hold queue already contains a note, dropping previous note");
							}
							_holdQueue[column] = note;
							break;
						case NoteType.SLIDE: // Hold/Roll end
							if ((note = _holdQueue[column]) != null) {
								note.AddPoint(time, column);
								this.AddNote(pattern, note);
								_holdQueue[column] = null;
							} else {
								this.Warning("Hold end note with no initial starting head");
							}
							break;
						default:
							// Don't do a warning because empties also go here
							break;
					}
				}
			}
		}

		public override void LoadPattern(Pattern pattern) {
			// Don't unnecessarily reload
			if (pattern.loaded == true) {
				return;
			}

			// Parse line-by-line
			_index = 0;
			_line = "";
			int beat = 0;
			List<string> measure = new List<string>();
			ReadAheadStreamReader reader = new ReadAheadStreamReader(_info.path);

			// Skip to main section
			while (_index < pattern.lineIndex) {
				_index++;
				reader.SkipLine();
			}

			// Parsing loop
			while (reader.PeekLine() != null) {
				_index++;
				_line = reader.ReadLine().Trim();

				// Empty line
				if (_line.Length == 0) {
					continue;
				// Comment
				} else if (_line[0] == '/') {
					continue;
				// New #NOTES section
				} else if (_line[0] == '#') {
					break; // End of pattern data
				// End of measure
				} else if (_line[0] == ',' || _line[0] == ';') {
					this.ParseMeasure(pattern, beat, measure);
					measure = new List<string>();
					beat += BEATS_PER_MEASURE;
					if (_line[0] == ';') {
						break; // End of pattern data,
					}
				// Pattern data
				} else {
					if (_line.Length != pattern.keyCount) {
						Warning("Line width does not match expected column count of " + pattern.keyCount);
					} else {
						measure.Add(_line);
					}
				}
			}

			// Add BPM change events
			foreach (Bpm bpm in _bpms) {
				Note note = new Note();
				note.type = NoteType.BPM;
				note.eventTime = this.CalculateTime(bpm.beat);
				note.eventFloatVal = bpm.bpm;
				this.AddNote(pattern, note);
			}

			// Add Stop events
			foreach (Stop stop in _stops) {
				Note note = new Note();
				note.type = NoteType.STOP;
				note.eventTime = this.CalculateTime(stop.beat);
				note.eventFloatVal = stop.beat;
				this.AddNote(pattern, note);
			}

			// Add background change events
			foreach (Bg bg in _bgs) {
				Note note = new Note();
				note.type = NoteType.BG;
				note.eventTime = this.CalculateTime(bg.beat);
				note.eventStringVal = bg.filename;
				this.AddNote(pattern, note);
			}

			// Add Label events
			foreach (Label label in _labels) {
				Note note = new Note();
				note.type = NoteType.LABEL;
				note.eventTime = this.CalculateTime(label.beat);
				note.eventStringVal = label.text;
				this.AddNote(pattern, note);
			}

			// Sort notes
			this.SortNotes(pattern);

			// Cleanup
			pattern.loaded = true;
			reader.Close();
		}
	}
}

